# 多标签页导航功能 - 技术设计文档

> **文档版本**: v1.0  
> **创建日期**: 2025-01-16  
> **负责人**: @产品, @开发  
> **目标**: 为 AI 开发者提供实现多标签页导航功能的完整技术指南。

---

## 1. 需求分析 (@产品)

### 1.1 功能概述

在应用主布局中增加一个多标签页导航栏，用于展示用户已打开的页面。用户可以通过点击标签页快速切换页面，并可通过右键菜单对标签页进行管理。

### 1.2 用户故事

- **As a** 用户,
- **I want** 能够以标签页的形式保留我打开过的页面,
- **So that** 我可以方便地在不同任务之间来回切换，而不用每次都从菜单重新进入。

- **As a** 用户,
- **I want** 能够通过右键菜单快捷地管理这些标签页,
- **So that** 我可以高效地关闭不需要的页面，保持工作区的整洁。

### 1.3 功能需求 (FRD)

#### FRD-1: 标签页展示
- 每次通过菜单访问新页面时，在标签页导航栏中自动新增一个对应的标签页。
- 标签页应显示页面的标题（从路由 `meta.title` 获取）。
- 登录页、404 等特殊页面不应出现在标签页中。
- 当前激活的页面，其对应的标签页应有高亮样式。

#### FRD-2: 标签页交互
- 点击标签页，应能切换到对应的页面视图。
- 每个标签页应有关闭按钮，点击可关闭当前标签页。
- 如果关闭的是当前激活的标签页，应自动激活其前一个或后一个标签页。
- 如果所有标签页都关闭了，应默认跳转到首页。

#### FRD-3: 右键快捷菜单
在标签页上右键，应弹出快捷菜单，提供以下操作：
| 菜单项 | 功能描述 |
|---|---|
| **重新加载** | 刷新当前标签页对应的页面内容，不刷新整个应用。 |
| **关闭** | 关闭当前标签页。 |
| **关闭左侧** | 关闭当前标签页左侧的所有标签页。 |
| **关闭右侧** | 关闭当前标签页右侧的所有标签页。 |
| **关闭其它** | 关闭除当前标签页外的所有其他标签页。 |
| **关闭全部** | 关闭所有标签页，并跳转到首页。 |

---

## 2. 技术方案 (@开发)

### 2.1 技术选型

- **状态管理**: `Pinia` - 用于管理标签页列表和当前激活的标签页状态。
- **UI 组件**:
    - `ant-design-vue` 的 `<a-tabs>` 用于展示和切换标签页。
    - `ant-design-vue` 的 `<a-dropdown>` 用于实现右键菜单。
- **路由**: `Vue Router` - 监听路由变化以动态增删标签页。

### 2.2 总体设计

我们将采用“**路由监听 + 状态管理 + 组件渲染**”的设计模式。

1.  **路由监听**: 使用 `router.afterEach` 导航守卫，在每次路由跳转成功后，捕获目标路由信息。
2.  **状态管理**: 创建一个独立的 Pinia store (`tabsStore`)，负责维护一个标签页列表 (`tabsList`)。导航守卫将捕获到的路由信息提交给 `tabsStore` 进行新增。
3.  **组件渲染**: 创建一个 `MultiTabs` 组件，该组件从 `tabsStore` 获取标签页列表并使用 `<a-tabs>` 进行渲染。用户的交互（点击、关闭、右键）会触发 `tabsStore` 中对应的 actions，实现状态变更和路由跳转。

### 2.3 文件结构

```
src/
├── components/
│   └── MultiTabs/
│       ├── MultiTabs.vue      # 标签页组件
│       └── types.ts           # 类型定义
├── store/
│   └── modules/
│       └── tabs.ts            # 标签页状态管理
├── router/
│   └── index.ts               # (修改) 添加 afterEach 守卫
└── App.vue                      # (修改) 引入 MultiTabs 组件
```

### 2.4 实现步骤

#### 步骤 1: 创建 Pinia Store (`tabs.ts`)

在 `src/store/modules/` 目录下创建 `tabs.ts`。

```typescript
// src/store/modules/tabs.ts

import { defineStore } from 'pinia'
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import type { RouteLocationNormalized } from 'vue-router'

// 定义 Tab 类型
export interface TabItem {
  path: string
  fullPath: string
  name: string
  title: string
  icon?: string
}

export const useTabsStore = defineStore('tabs', () => {
  const router = useRouter()

  // 状态
  const tabsList = ref<TabItem[]>([])
  const activeTabPath = ref<string>('')

  // Actions
  /**
   * 添加一个新标签页
   * @param route - 路由信息
   */
  function addTab(route: RouteLocationNormalized) {
    // 忽略特定路由
    if (route.path === '/login' || route.meta?.hideInTab) {
      return
    }

    // 检查标签页是否已存在
    const isExists = tabsList.value.some(tab => tab.path === route.path)
    if (!isExists) {
      tabsList.value.push({
        path: route.path,
        fullPath: route.fullPath,
        name: route.name as string,
        title: route.meta.title as string,
        icon: route.meta.icon as string,
      })
    }
    activeTabPath.value = route.path
  }

  /**
   * 移除一个标签页
   * @param path - 标签页路径
   */
  function removeTab(path: string) {
    const index = tabsList.value.findIndex(tab => tab.path === path)
    if (index === -1) return

    // 如果关闭的是当前激活的 tab，则需要切换到其他 tab
    if (activeTabPath.value === path) {
      const nextTab = tabsList.value[index + 1] || tabsList.value[index - 1]
      if (nextTab) {
        router.push(nextTab.path)
      } else {
        router.push('/') // 如果没有其他 tab，回到首页
      }
    }
    tabsList.value.splice(index, 1)
  }

  /**
   * 关闭其他标签页
   * @param path - 保留的标签页路径
   */
  function closeOtherTabs(path: string) {
    tabsList.value = tabsList.value.filter(tab => tab.path === path)
    if (activeTabPath.value !== path) {
        router.push(path)
    }
  }

  /**
   * 关闭所有标签页
   */
  function closeAllTabs() {
    tabsList.value = []
    router.push('/')
  }
  
  // ... 其他关闭方法（如 closeLeft, closeRight）的实现

  return {
    tabsList,
    activeTabPath,
    addTab,
    removeTab,
    closeOtherTabs,
    closeAllTabs,
  }
}, {
  persist: true // 启用持久化
})
```

#### 步骤 2: 创建 `MultiTabs` 组件

在 `src/components/MultiTabs/` 目录下创建 `MultiTabs.vue`。

```vue
<!-- src/components/MultiTabs/MultiTabs.vue -->
<template>
  <div class="multi-tabs-container">
    <a-tabs
      v-model:activeKey="activeKey"
      type="editable-card"
      hide-add
      @tab-click="handleTabClick"
      @edit="handleTabEdit"
    >
      <a-tab-pane
        v-for="tab in tabsStore.tabsList"
        :key="tab.path"
      >
        <template #tab>
          <a-dropdown :trigger="['contextmenu']">
            <span>{{ tab.title }}</span>
            <template #overlay>
              <a-menu @click="({ key }) => handleMenuClick(key, tab.path)">
                <a-menu-item key="reload">重新加载</a-menu-item>
                <a-menu-item key="close">关闭</a-menu-item>
                <a-menu-divider />
                <a-menu-item key="closeOther">关闭其它</a-menu-item>
                <a-menu-item key="closeAll">关闭全部</a-menu-item>
              </a-menu>
            </template>
          </a-dropdown>
        </template>
      </a-tab-pane>
    </a-tabs>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import { useTabsStore } from '@/store/modules/tabs'

const router = useRouter()
const tabsStore = useTabsStore()

const activeKey = computed({
  get: () => tabsStore.activeTabPath,
  set: (val) => tabsStore.activeTabPath = val
})

// 点击标签页
const handleTabClick = (path: string) => {
  router.push(path)
}

// 关闭标签页
const handleTabEdit = (targetKey: string, action: 'add' | 'remove') => {
  if (action === 'remove') {
    tabsStore.removeTab(targetKey)
  }
}

// 右键菜单点击
const handleMenuClick = (key: string, path: string) => {
  switch (key) {
    case 'reload':
      // 实现刷新逻辑 (详见 2.5)
      break
    case 'close':
      tabsStore.removeTab(path)
      break
    case 'closeOther':
      tabsStore.closeOtherTabs(path)
      break
    case 'closeAll':
      tabsStore.closeAllTabs()
      break
  }
}
</script>

<style scoped>
/* 添加一些基础样式 */
.multi-tabs-container {
  background-color: #fff;
  padding: 6px 10px;
  border-bottom: 1px solid #d9d9d9;
}
:deep(.ant-tabs-bar) {
  margin: 0;
}
</style>
```

#### 步骤 3: 监听路由变化

修改 `src/router/index.ts`，添加 `afterEach` 守卫。

```typescript
// src/router/index.ts
import { useTabsStore } from '@/store/modules/tabs'

// ... router 创建代码之后

router.afterEach((to) => {
  // 在 Pinia 实例化后才能获取 store
  const tabsStore = useTabsStore()
  tabsStore.addTab(to)
})
```

**注意**: 确保 Pinia 实例在路由守卫执行前已经被创建。通常在 `main.ts` 中，`app.use(router)` 之前 `app.use(pinia)` 即可保证。

#### 步骤 4: 整合到主布局

修改 `src/App.vue`，在布局中引入 `MultiTabs` 组件。最佳位置通常是在 `<a-layout-header>` 之后。

```vue
<!-- src/App.vue -->
<template>
  <a-layout class="main-layout">
    <a-layout-header class="layout-header">
      <!-- ... header 内容 ... -->
    </a-layout-header>
    
    <!-- 新增 MultiTabs 组件 -->
    <MultiTabs />
    
    <a-layout-content class="layout-content">
      <router-view />
    </a-layout-content>
  </a-layout>
</template>

<script setup lang="ts">
import MultiTabs from '@/components/MultiTabs/MultiTabs.vue'
// ... 其他 import
</script>
```

### 2.5 "重新加载"功能实现策略

页面刷新是一个特殊场景，推荐使用 `provide/inject` 和 `v-if` 结合的方式实现。

1.  **在 `App.vue` 中提供一个刷新函数**:

    ```typescript
    // src/App.vue
    import { ref, provide, nextTick } from 'vue'

    const isRouterAlive = ref(true)
    const reloadPage = () => {
      isRouterAlive.value = false
      nextTick(() => {
        isRouterAlive.value = true
      })
    }
    provide('reloadPage', reloadPage)
    ```

    并修改 `<router-view>`:

    ```vue
    <router-view v-if="isRouterAlive" />
    ```

2.  **在 `MultiTabs.vue` 中注入并调用**:

    ```typescript
    // src/components/MultiTabs/MultiTabs.vue
    import { inject } from 'vue'
    
    const reloadPage = inject('reloadPage') as () => void

    // ... in handleMenuClick
    case 'reload':
      if (reloadPage) reloadPage()
      break
    ```

---

## 3. 验收标准

- **功能验收**:
  - [ ] 路由切换时，标签页正常新增和激活。
  - [ ] 点击标签页可以跳转到对应页面。
  - [ ] 关闭按钮功能正常。
  - [ ] 右键菜单所有功能符合预期。
  - [ ] 页面刷新后，已打开的标签页能够被保留（如果启用了持久化）。
- **技术验收**:
  - [ ] 代码遵循上述文件结构和技术方案。
  - [ ] Pinia store 逻辑清晰，状态变更可追溯。
  - [ ] 组件封装良好，与业务逻辑解耦。
  - [ ] 无控制台报错。

---
**文档结束**
